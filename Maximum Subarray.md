## 问题分析：
#### 求最大子数组之和
每一步维护两个变量，全局最优(到当前元素为止最优的解)和局部最优(必须包含当前元素的最优的解)
## 编程实现：
```C++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        if(nums.size()==0) return 0;
        int x=INT_MIN,y=0;//先定义x为最小再不断取代
        for(int num : nums)//用法存疑
        {
            y=max(y+num,num);
            x=max(x,y);
        }
        return x;
    }
};
```
## 总结体会：
* 是数组中求最大值的子数组所以数字排列顺序不变,遍历每一个数字然后将这个数字与之前数字的和+这个数字比较大小来决定哪一个大来存入最终的数组中
* 其中x保存最终要返回的结果,即最大的子数组之和,y初始值为0,每遍历一个数字num,比较y+num和num中的较大值存入y,
  然后再把x和y中的较大值存入x,以此类推直到遍历完整个数组,可得到最大子数组的值存在x中
